---
title: "EucFACE Simulation Output Validation"
author: "Mingkai Jiang"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      out.height="50%")


#### clear wk space
rm(list=ls(all=TRUE))

#### Source functions and packages
source("prepare.R")

#### select the model abbreviation
#### options are:
####             GDAYN: GDAY, CN version
####             GDAYP: GDAY, CNP version
####             QUNIC: QUINCY
####             OCHDP: ORCHIDEE, CNP version
####             OCHDN: ORCHIDEE, CN version
####             LPJGN: LPJ-Guess, CN version
####             LPJGP: LPJ-Guess, CNP version
####             CABLP: CABLE-POP, CNP version
####             ELMXX: ELM, CNP version

mod.abb <- "QUJSM"


```



```{r, echo=FALSE, message=FALSE, warning=FALSE}
### translate model-specific output into the requested output format
translate_GDAY_simulation_into_EucFACE_MIP_format(met.path ="/Users/mingkaijiang/Documents/Research/Projects/EucFACE_Modeling/GDAY-EucFACE/met_data",
                                                  sim.path = "/Users/mingkaijiang/Documents/Research/Projects/EucFACE_Modeling/GDAY-EucFACE/outputs",
                                                  out.path = "simulation_output")


```


## 1. Introduction

\
This is an R Markdown document to evaluate the model simulation results for the new EucFACE multi-model intercomparison project, based on mass balance checks and validation datasets. 

\
To use this Markdown, please create two folders within this repository and place the relevant data files into each folder. 

- Create a folder "simulation_output", and place the model simulation results into this folder (note, only the file containing ambient treatment over the period of 2012 - 2019).

- Create a folder "validation_dataset", and place the validation datasets into this folder (data can be obtained via the CloudStor link sent previously).


\
This output of this script is organized in the following order:

* Step 2: Checking mass balance. This section will check mass balance of model output, including major carbon, water, nitrogen and phosphorus cycle variables.  
* Step 3: Checking time-invariance variables against validation data. This section will check some key pools and fluxes against the validation dataset. All validation data are provided in the EucFACE parameter list file. Note that the data are either averaged over time, or one fixed value measured at one point. 
* Step 4: Checking time-varying variables against some validation data. This section will check some temporal patterns of the simulation results against some validation datasets. 

\
Finally, please note that, all checks are performed for the ambient CO2 treatment only, over the period where observations are available (i.e. 2012 - 2019). For the validation against observation dataset, please also use simulation results under the no P addition and variable climate forcing scenario. 
\


```{r, echo=FALSE, message=FALSE, warning=FALSE}
### read in simulation results and get it in shape for comparison.
### the naming of the file follows the output protocol. 
### Note that this is the daily file. 
### You can modify this path to read in different files. 
modDF <- read.csv(paste0("simulation_output/EUC_", mod.abb, "_OBS_VAR_AMB_NOP_D.csv"))

### checking number of column in the original dataframe
ncol <- ncol(modDF)
#print(paste0("no. of columns is ", ncol))

# check length of frames, need to be TRUE, otherwise you have too many or little days
# 8 years with 365 days plus 2 years with a leap day! (for those models that do not model leap days, please repeat Feb 28 to fill Feb 29)
if (nrow(modDF)!=(8*365)+2) {
  print(paste("number of rows of model output does not match, all further results unreliable!!"))
}


### add date to the dataset to help with the plotting
for (i in 2012:2019) {
    
    date.list <- as.Date((modDF$DOY[modDF$YEAR==i]-1), 
                                           origin = paste0(i, "-01-01"))
    
    modDF$Date[modDF$YEAR == i] <- as.character(date.list)
}

modDF$Date <- as.Date(modDF$Date)


########################################################################################################
### add other variables not defined in the protocol but are potentially important for this MIP



########################################################################################################


#modDF$Transpiration <- modDF$Transpiration * 100 / 1000 # kg H2O m2 d-1
#modDF$ET <- modDF$ET * 100 / 1000 # kg H2O m2 d-1
#modDF$ES <- modDF$ES * 100 / 1000 # kg H2O m2 d-1
#modDF$EC <- modDF$EC * 100 / 1000 # kg H2O m2 d-1
#modDF$RO <- modDF$RO * 100 / 1000 # kg H2O m2 d-1
#modDF$DRAIN <- modDF$DRAIN * 100 / 1000 # kg H2O m2 d-1


```



## 2. Checking mass balance

\
We will need to check mass balance for major variables first before validating the simulation results with observations. The mass balance check is performed at annual timestep. 

\
Below we check the mass balance for carbon, water, nitrogen and phopshorus variables, each with a plot. 

\
Note that, I assume that many models may not output some of these variables, and as such, the mass balance may not close without the inclusion model-specific variables. For those that are relevant, please modify the script with additional/alternative variables to try to close the mass balance. Otherwise, please indicate the reasons as to why your model does not have mass balance closure.
\


```{r, echo=FALSE, message=FALSE, warning=FALSE}

### summarize all fluxes first to obain annual rate
fluxDF <- summaryBy(PREC+ET+TRANS+ES+EC+RO+DRAIN+NEP+GPP+NPP+RHET+RAU+RECO+CGL+CGFR+CGCR+CGW+NGL+NGFR+NGCR+NGW+PGL+PGFR+PGCR+PGW+NUP+NGMIN+NMIN+NLEACH+PUP+PGMIN+PMIN+PLEACH+PBIOCHMIN+NLRETR+PLRETR+RCR+RFR+CREPR+CEX+CVOC+RL+RW+RGR+CLITIN+CCRLIN+CFRLIN+CWLIN+NLITIN+NCRLIN+NFRLIN+NWLIN+PLITIN+PCRLIN+PFRLIN+PWLIN+NWRETR+PWRETR+NCRRETR+PCRRETR+NFRRETR+PFRRETR+NDEP+NFIX+NVOL+PDEP+PWEA~YEAR, data=modDF, FUN=sum, keep.names=T, na.rm=T)


### subset first day within a year of all pools
poolDF <- modDF[,c("YEAR", "DOY", "SW", "CL","LAI","CW","CFR","CCR","NL","NW","NFR","NCR","PL","PW","PFR","PCR","CSTOR","NSTOR","PSTOR",
                   "CSOIL","NSOIL","PSOIL","NPMIN","PPMIN","PLAB","PSEC","POCC","PPAR","CFLIT","CFLITA","CFLITB",
                   "NFLITA","NFLITB","PFLITA","PFLITB","CCLITB","NCLITB","PCLITB","NFLIT","PFLIT", "NPORG", "PPORG")]

poolDF <- subset(poolDF, DOY==1)

poolDF$DOY <- NULL

### calculate change in pools for mass balance
deltaDF <- poolDF[poolDF$YEAR < 2019,]

l <- dim(deltaDF)[2]

for (i in c(2012:2018)) {
    deltaDF[deltaDF$YEAR==i,2:l] <- poolDF[poolDF$YEAR==(i+1),2:l]-poolDF[poolDF$YEAR==i,2:l]
}

### add delta column name to deltaDF
names(deltaDF)[2:l] <- paste0("delta", names(deltaDF[2:l]))

### merge all dataframe together
annDF <- merge(fluxDF, poolDF, by="YEAR")
annDF <- merge(annDF, deltaDF, by="YEAR", all.x=T)

### calculate annual maximum for some variables
maxDF <- summaryBy(LAI+CL+CFR+CSTOR+NL+NFR+NSTOR+PL+NFR+PSTOR~YEAR, data=modDF, keep.names=T, na.rm=T)


### test script
#write.csv(annDF, "validation_output/annDF.csv",row.names=F)

```



#### 2.1 Carbon balance

\
Now we plot carbon-related mass balance results. We check major carbon fluxes (e.g. GPP) and changes in pools.

\
Firstly, we can whether NPP + RAU = GPP. All models should get this right, but note that some models may assume a simple CUE relationship. 


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on GPP", fig.align="center"}

### NPP + RAU = GPP
### all models should get this right,
### but note that some models may simply assume a fixed CUE to get RAU (e.g. GDAY)
p1<-xyplot(I(NPP+RAU)~GPP,fluxDF,
           #main='NPP+RAU~GPP',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```


\
This is an alternative way to check mass balance for GPP, that is, NEP + RECO = GPP. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on GPP", fig.align="center"}

### NEP + RECO = GPP
p1<-xyplot(I(NEP+RECO)~GPP,fluxDF,
           #main='NEP+RECO~GPP',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```

\
Ecosystem respiration (RECO) should be the sum of autotrophic (RAU) and heterotrophic respiration (RHET). 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on RECO", fig.align="center"}

### RHET + RAU = RECO
p1<-xyplot(I(RHET+RAU)~RECO,fluxDF,
           #main='RHET+RAUTO~RECO',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```

\
This is to sum all autotrophic respiration fluxes, including RL, RW, RCR, RFR, and RGR. Note that some models may not explicitly simulate some individual respiratory fluxes. Hence, this mass balance check may not be closed for some models. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on RAU", fig.align="center"}

### sum of all autotrophic respiration fluxes
### Some models may not explicitly simulate individual respiratory fluxes (e.g. GDAY)
### Hence, this mass balance check may not be closed for all models. 
p1<-xyplot(I(RL+RW+RCR+RFR+RGR)~RAU,fluxDF,
           #main='RL+RW+RCR+RFR+RGR~RAU',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```


\
This is not a strict mass balance check, but rather, to see how LAI scales with leaf carbon pool. Given that we provided SLA, one can and should practically close the mass balance by modifying the equation in the code. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Scaling of LAI with CL", fig.align="center"}

### This is not a mass balance check, but rather, to see how LAI scales with leaf carbon pool.
### Given that we provided SLA, we can use
p1<-xyplot(LAI~CL,poolDF,
           #main='LAI~CL',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```

\
This is to check the mass balance on change in leaf carbon pool (i.e. $\Delta$CL). $\Delta$CL should equals influx - outflux, in this case, CGL+CLITIN. Same expectation for $\Delta$CW, $\Delta$CFR, and $\Delta$CCR.

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta CL", fig.align="center"}

p1<-xyplot(I(CGL-CLITIN)~deltaCL,annDF,
           #main='CGL-CLITIN~deltaCL',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta CW", fig.align="center"}

p1<-xyplot(I(CGW-CWLIN)~deltaCW,annDF,
           #main='CGW-CWLIN~deltaCW',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta CFR", fig.align="center"}

p1<-xyplot(I(CGFR-CFRLIN)~deltaCFR,annDF,
           #main='CGFR-CFRLIN~deltaCFR',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta CCR", fig.align="center"}

p1<-xyplot(I(CGCR-CCRLIN)~deltaCCR,annDF,
           #main='CGCR-CCRLIN~deltaCCR',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```

\
GPP should in theory equals to individual production fluxes and respiratory flux. Here production fluxes include: CGL, CGFR, CGCR, CGW and CREPR, and the respiratory flux is RAU. If there is an exudation flux, make it part of GPP too.


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on GPP", fig.align="center"}

p1<-xyplot(I(RAU+CGL+CGFR+CGCR+CGW+CREPR+CEX)~GPP,annDF,
           #main='I(RAU+CGL+CGFR+CGCR+CGW+CREPR)~GPP',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```




\
Similarly, NPP should equal to all growth fluxes, that is, the sum of CGL, CGFR, CGCR, CGW, CREPR, and CEX.

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on NPP", fig.align="center"}

p1<-xyplot(I(CGW+CGL+CGFR+CGCR+CREPR+CEX)~NPP,annDF,
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



\
This is a different way to check mass balance for NPP, in that it includes $\Delta$CSTOR in addition to those growth fluxes included in the previous figure. Some models don't explictly simulate CSTOR, so this mass balance may not apply. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on NPP", fig.align="center"}

p1<-xyplot(I(CGW+CGL+CGFR+CGCR+CREPR+CEX+deltaCSTOR)~NPP,annDF,
           #main='I(CGW+CGL+CGFR+CGCR+CREPR+deltaCSTOR)~NPP',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```


\
Here, CFLIT = CFLITA + CFLITB. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on CFLIT", fig.align="center"}

p1<-xyplot(I(CFLITA+CFLITB)~CFLIT,annDF,
           #main='CFLITA+CFLITB~CFLIT',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```

\
This mass balance equation checks the net of total influx litter and heterotrophic respiration. In theory, the net difference of these two flues should equal to the change in soil + litter pool. Note that CEX was included as an additional influx into the soil. The full equation is: 

<center> CLITIN+CWLIN+CFRLIN+CCRLIN+CREPR+CEX-RHET = $\Delta$CSOIL+$\Delta$CCLITB+$\Delta$CFLIT </center>


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta soil", fig.align="center"}

p1<-xyplot(I(CEX+CLITIN+CWLIN+CFRLIN+CCRLIN+CREPR-RHET)~I(deltaCSOIL+deltaCCLITB+deltaCFLIT),annDF,
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```



#### 2.2. Water balance

\
The water budget will need to be closed in order to investigate the CO2 x water interaction. Firstly, the total evapotranspiration flux (ET) should equal to total transpiration (T) + evaporation fluxes (ES + EC). 

\
More water balance checks to be added. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on ET", fig.align="center"}

p1<-xyplot(I(ES+EC+TRANS)~ET,fluxDF,
           #main='ES+EC+T~ET',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)

```


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on ET", fig.align="center"}

p2<-xyplot(I(PREC-(RO+DRAIN+ET))~deltaSW, annDF,
           #main='PREC-RO-DRAIN-ET~deltaSW',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)})

plot(p2)

```


#### 2.3. Nitrogen balance

\
Now we plot some nitrogen balance checks. Firstly, we check $\Delta$NL, $\Delta$NW, $\Delta$NFR and $\Delta$NCR. Here, $\Delta$NL = NGL + NLITIN - NLRETR, where NLRETR is the retranslocation flux. 


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta NL", fig.align="center"}

p1<-xyplot(I(NGL-NLITIN-NLRETR)~deltaNL,annDF,
           #main='I(NGL-NLITIN-NLRETR)~deltaNL',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta NW", fig.align="center"}

p1<-xyplot(I(NGW-NWLIN-NWRETR)~deltaNW,annDF,
           #main='I(NGW-NWLIN-NWRETR)~deltaNW',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta NFR", fig.align="center"}

p1<-xyplot(I(NGFR-NFRLIN-NFRRETR)~deltaNFR,annDF,
           #main='I(NGFR-NFRLIN-NFRRETR)~deltaNFR',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```



```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta NCR", fig.align="center"}

p1<-xyplot(I(NGCR-NCRLIN-NCRRETR)~deltaNCR,annDF,
           #main='I(NGCR-NCRLIN-NCRRETR)~deltaNCR',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

\
This is to check finelitter influx. Total NFLIT = NFLITA + NFLITB. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on NFLIT", fig.align="center"}

p1<-xyplot(I(NFLITA+NFLITB)~NFLIT,annDF,
           #main='I(NFLITA+NFLITB)~NFLIT',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

\
Now, we check mass balance of total N required to support the new growth, which should euqal to the sum of nitrogen uptake and total retranslocation fluxes. The full equation is written as:

<center> 
NUP+NLRETR+NWRETR+NFRRETR+NCRRETR = NGL+NGFR+NGCR+NGW
</center> 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on vegetation N requirement", fig.align="center"}

p1<-xyplot(I(NUP+NLRETR+NWRETR+NFRRETR+NCRRETR)~I(NGL+NGFR+NGCR+NGW),annDF,
           #main='I(NUP+NLRETR+NWRETR+NFRRETR+NCRRETR)~I(NGL+NGFR+NGCR+NGW)',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

\
Some models could have a NSTOR pool, so not all nitrogen available for plant is used for growth. Here we are looking at $\Delta$NSTOR to see if it helps to close the mass balance if the figure above doesn't close its mass balance. 


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta NSTOR", fig.align="center"}

p1<-xyplot(I(NUP+NLRETR+NWRETR+NFRRETR+NCRRETR-NGL-NGFR-NGCR-NGW)~deltaNSTOR,annDF,
           #main='I(NUP+NLRETR+NWRETR+NFRRETR+NCRRETR-NGL-NGFR-NGCR-NGW)~deltaNSTOR',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

\
N fixation could also be added to plant directly. So here we are checking its effect. Full equation is: 

<center> 
NFIX+NUP+NLRETR+NWRETR+NFRRETR+NCRRETR = NGL+NGFR+NGCR+NGW
</center> 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on N input and output", fig.align="center"}

p1<-xyplot(I(NFIX+NUP+NLRETR+NWRETR+NFRRETR+NCRRETR)~I(NGL+NGFR+NGCR+NGW),annDF,
           #main='I(NFIX+NUP+NLRETR+NWRETR+NFRRETR+NCRRETR)~I(NGL+NGFR+NGCR+NGW)',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

\
Similar to the above figure, we are checking if $\Delta$NSTOR helps to close the budget. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on N input and output", fig.align="center"}

p1<-xyplot(I(NFIX+NUP+NLRETR+NWRETR+NFRRETR+NCRRETR-NGL-NGFR-NGCR-NGW)~deltaNSTOR,annDF,
           #main='I(NFIX+NUP+NLRETR+NWRETR+NFRRETR+NCRRETR-NGL-NGFR-NGCR-NGW)~deltaNSTOR',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

\
Now we are checking the whole ecosystem N input and output. Full equation is:

<center> 
NDEP+NFIX-NLEACH-NVOL = $\Delta$NL+$\Delta$NW+$\Delta$NCR+$\Delta$NFR+$\Delta$NSOIL+$\Delta$NFLIT+$\Delta$NCLITB
</center> 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on ecosystem N", fig.align="center"}

p1<-xyplot(I(NDEP+NFIX-NLEACH-NVOL)~(I(deltaNL+deltaNW+deltaNCR+deltaNFR+deltaNSOIL+deltaNFLIT+deltaNCLITB)),annDF,
           #main='I(NDEP+NFIX-NLEACH-NVOL)~(I(deltaNL+deltaNW+deltaNCR+deltaNFR+deltaNSOIL+deltaNFLIT+deltaNCLITB))',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

\
A different way to check whole ecosystem N budget, as:

<center> 
NDEP+NFIX+NLITIN+NWLIN+NCRLIN+NFRLIN-NUP-NLEACH-NVOL = $\Delta$NSOIL+$\Delta$NFLIT+$\Delta$NCLITB
</center> 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on ecosystem N", fig.align="center"}

p1<-xyplot(I(NDEP+NFIX+NLITIN+NWLIN+NCRLIN+NFRLIN-NUP-NLEACH-NVOL)~I(deltaNSOIL+deltaNFLIT+deltaNCLITB),annDF,
           #main='I(NDEP+NFIX+NLITIN+NWLIN+NCRLIN+NFRLIN-NUP-NLEACH-NVOL)~I(deltaNSOIL+deltaNFLIT+deltaNCLITB)',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

\
Another way to check ecosystem N budget, by excluding NFIX:

<center> 
NDEP+NLITIN+NWLIN+NCRLIN+NFRLIN-NUP-NLEACH-NVOL = $\Delta$NSOIL+$\Delta$NFLIT+$\Delta$NCLITB
</center> 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on ecosystem N", fig.align="center"}

p1<-xyplot(I(NDEP+NLITIN+NWLIN+NCRLIN+NFRLIN-NUP-NLEACH-NVOL)~I(deltaNSOIL+deltaNFLIT+deltaNCLITB),annDF,
           #main='I(NDEP+NLITIN+NWLIN+NCRLIN+NFRLIN-NUP-NLEACH-NVOL)~I(deltaNSOIL+deltaNFLIT+deltaNCLITB)',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

\
We now check the mass balance for NSOIL, which should equal to total organic and inorganic pools. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on soil N", fig.align="center"}

p1<-xyplot(I(NPMIN+NPORG)~NSOIL,annDF,
           #main='I(NPMIN+NPORG)~NSOIL',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```



#### 2.4 Phosphorus balance

\
Finally, we plot the phosphorus balance checks. The net influx - outflux should equal to the change in all ecosystem P pools: 

<center> 
PDEP+PWEA-PLEACH = $\Delta$PL+$\Delta$PW+$\Delta$PCR+$\Delta$PFR+$\Delta$PSOIL+$\Delta$PFLIT+$\Delta$PCLITB
</center> 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on P input and output", fig.align="center"}

p1<-xyplot(I(PDEP+PWEA-PLEACH)~(I(deltaPL+deltaPW+deltaPCR+deltaPFR+deltaPSOIL+deltaPFLIT+deltaPCLITB)),annDF,
           #main='I(PDEP+PWEA-PLEACH)~(I(deltaPL+deltaPW+deltaPCR+deltaPFR+deltaPSOIL+deltaPFLIT+deltaPCLITB))',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

\
Next, we check changes in major vegetation P pools. It should equal to production flux - retranslocation flux - litterfall. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta PL", fig.align="center"}

p1<-xyplot(I(PGL-PLITIN-PLRETR)~deltaPL,annDF,
           #main='I(PGL-PLITIN-PLRETR)~deltaPL',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta PW", fig.align="center"}

p1<-xyplot(I(PGW-PWLIN-PWRETR)~deltaPW,annDF,
           #main='I(PGW-PWLIN-PWRETR)~deltaPW',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta PFR", fig.align="center"}

p1<-xyplot(I(PGFR-PFRLIN-PFRRETR)~deltaPFR,annDF,
           #main='I(PGFR-PFRLIN-PFRRETR)~deltaPFR',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on delta PCR", fig.align="center"}

p1<-xyplot(I(PGCR-PCRLIN-PCRRETR)~deltaPCR,annDF,
           #main='I(PGCR-PCRLIN-PCRRETR)~deltaPCR',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

\
This is to check P litter flux. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on PFLIT", fig.align="center"}

p1<-xyplot(I(PFLITA+PFLITB)~PFLIT,annDF,
           #main='I(PFLITA+PFLITB)~PFLIT',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

\
Now we check the total P required to make new vegetation: 

<center> 
PUP+PLRETR+PWRETR+PFRRETR+PCRRETR=PGL+PGFR+PGCR+PGW
</center> 


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on P storage", fig.align="center"}

p1<-xyplot(I(PUP+PLRETR+PWRETR+PFRRETR+PCRRETR)~I(PGL+PGFR+PGCR+PGW),annDF,
           #main='I(PUP+PLRETR+PWRETR+PFRRETR+PCRRETR)~I(PGL+PGFR+PGCR+PGW)',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

\
This is to consider the effect of $\Delta$PSTOR. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on P storage", fig.align="center"}

p1<-xyplot(I(PUP+PLRETR+PWRETR+PFRRETR+PCRRETR-PGL-PGFR-PGCR-PGW)~deltaPSTOR,annDF,
           #main='I(PUP+PLRETR+PWRETR+PFRRETR+PCRRETR-PGL-PGFR-PGCR-PGW)~deltaPSTOR',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

\
This is to check whole ecosystem P flux, which means that total in - out = net change:

<center> 
PDEP+PWEA+PLITIN+PWLIN+PCRLIN+PFRLIN-PUP-PLEACH = $\Delta$PSOIL+$\Delta$PFLIT+$\Delta$PCLITB
</center> 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on P storage", fig.align="center"}

p1<-xyplot(I(PDEP+PWEA+PLITIN+PWLIN+PCRLIN+PFRLIN-PUP-PLEACH)~I(deltaPSOIL+deltaPFLIT+deltaPCLITB),annDF,
           #main='I(PDEP+PWEA+PLITIN+PWLIN+PCRLIN+PFRLIN-PUP-PLEACH)~I(deltaPSOIL+deltaPFLIT+deltaPCLITB)',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

\
Now to check a basic mass balance on soil P. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on P soil", fig.align="center"}

p1<-xyplot(I(PPMIN+PPORG)~PSOIL,annDF,
           #main='I(PPMIN+PPORG)~PSOIL',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```

\
Inorganic P pool in soils: PLAB+PSEC+POCC+PPAR=PPMIN


```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on inorganic P", fig.align="center"}

p1<-xyplot(I(PLAB+PSEC+POCC+PPAR)~PPMIN,annDF,
           #main='I(PLAB+PSEC+POCC+PPAR)~PPMIN',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```


\
A different way to check PSOIL. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.cap = "Mass balance check on inorganic P", fig.align="center"}

p1<-xyplot(I(PLAB+PSEC+POCC+PPAR+PPORG)~PSOIL,annDF,
           #main='I(PLAB+PSEC+POCC+PPAR+PPORG)~PSOIL',
           auto.key=T,
           scales=list(relation='free'),
           panel=function(...){
             panel.xyplot(...)
             panel.abline(a=0,b=1)}) 

plot(p1)


```



## 3. Checking time-invariant variables against validation data


#### Major carbon pools

\
Firstly we will check the major carbon pools, as these data are provided in Table 1 in the parameter file. 

\
Note that:
      
* CFR combines fineroot (< 2 mm in diameter) and intermediate root (2-3 mm) in the observation;
* CSOIL is for top 10 cm of soil in the observation;
* CL includes overstorey leaf only in the observation;
* CW includes branch and stem in the model simulation.

\
Now we make the tables to compare simulation results with observation data.


```{r, echo=FALSE, message=FALSE, warning=FALSE}

### create a DF to store observation data for vegetation carbon stocks
vegDF <- data.frame(c("CL", "CW", "CFR", "CCR", "CSOIL"), NA, NA)
colnames(vegDF) <- c("Variable", 
                     "observed",
                     "simulated")

vegDF$observed[vegDF$Variable=="CL"] <- "151 ± 14"
vegDF$observed[vegDF$Variable=="CW"] <- "4558 ± 321"
vegDF$observed[vegDF$Variable=="CFR"] <- "227 ± 5"
vegDF$observed[vegDF$Variable=="CCR"] <- "606 ± 60"
vegDF$observed[vegDF$Variable=="CSOIL"] <- "2183 ± 280"


### calcualte annual means in the simulated data
poolDF <- subset(modDF, YEAR <= 2016 & YEAR > 2012)

poolDF <- summaryBy(CL+CW+CFR+CCR+CSOIL~YEAR, data=poolDF, FUN=mean, na.rm=T, keep.names=T)

### assign values
vegDF$simulated[vegDF$Variable=="CL"] <- round(poolDF$CL[poolDF$YEAR=="2016"], 0)
vegDF$simulated[vegDF$Variable=="CW"] <- round(poolDF$CW[poolDF$YEAR=="2016"], 0)
vegDF$simulated[vegDF$Variable=="CFR"] <- round(poolDF$CFR[poolDF$YEAR=="2016"], 0)
vegDF$simulated[vegDF$Variable=="CCR"] <- round(poolDF$CCR[poolDF$YEAR=="2016"], 0)
vegDF$simulated[vegDF$Variable=="CSOIL"] <- round(poolDF$CSOIL[poolDF$YEAR=="2016"], 0)

knitr::kable(vegDF, caption = "Validation of major carbon pools")

```


#### Allocation coefficients

\
Allocation coefficients are calculated different comparing the data and the model. In the EucFACE data, allocation to leaf includes allocation to overstorey and understorey leaves, and allocation to root includes allocation to overstorey and understorey roots. In the data, there is also an additional allocation coefficient to Mycorrhizae, which can be grouped with allocation to root as total belowground allocation. This total belowground allocation is comparable to allocation coefficient to root in the model. 


```{r, echo=FALSE, message=FALSE, warning=FALSE}

### create a DF to store observation data for allocation coefficients
allocDF <- data.frame(c("leaf", "wood", "root", "exudation", "belowground"), NA, NA)
colnames(allocDF) <- c("Variable", 
                        "observed",
                        "simulated")

allocDF$observed[allocDF$Variable=="leaf"] <- "0.48 ± 0.04"
allocDF$observed[allocDF$Variable=="wood"] <- "0.20 ± 0.03"
allocDF$observed[allocDF$Variable=="root"] <- "0.22 ± 0.05"
allocDF$observed[allocDF$Variable=="exudation"] <- "0.10 ± 0.07"
allocDF$observed[allocDF$Variable=="belowground"] <- "0.32"


### calcualte annual means in the simulated data
subDF <- subset(modDF, YEAR <= 2016 & YEAR > 2012)

fluxDF <- summaryBy(GPP+NEP+NPP+CGL+CGW+CGFR+CGCR+CEX+RAU~YEAR, data=subDF, FUN=sum, na.rm=T, keep.names=T)

### assign values
allocDF$simulated[allocDF$Variable=="leaf"] <- round(mean(fluxDF$CGL/fluxDF$NPP),2)
allocDF$simulated[allocDF$Variable=="wood"] <- round(mean(fluxDF$CGW/fluxDF$NPP),2)
allocDF$simulated[allocDF$Variable=="root"] <- round(mean((fluxDF$CGFR+fluxDF$CGCR)/fluxDF$NPP),2)
allocDF$simulated[allocDF$Variable=="exudation"] <- round(mean((fluxDF$CEX)/fluxDF$NPP),2)
allocDF$simulated[allocDF$Variable=="belowground"] <- round(mean((fluxDF$CGFR+fluxDF$CGCR+fluxDF$CEX)/fluxDF$NPP),2)

knitr::kable(allocDF, caption = "Validation of major carbon pools")

```



#### Major carbon fluxes

\
We now summarize major carbon fluxes (e.g. GPP, NPP, NEP, CUE).

```{r, echo=FALSE, message=FALSE, warning=FALSE}

### create a DF to store observation data for allocation coefficients
outDF <- data.frame(c("NEP", "GPP", "NPP", "CUE", "RAU"), NA, NA)
colnames(outDF) <- c("Variable", 
                     "observed",
                     "simulated")

outDF$observed[outDF$Variable=="NEP"] <- "-73 to 28"
outDF$observed[outDF$Variable=="GPP"] <- "1563 ± 200"
outDF$observed[outDF$Variable=="NPP"] <- "484 ± 63"
outDF$observed[outDF$Variable=="CUE"] <- "0.31 ± 0.03"
outDF$observed[outDF$Variable=="RAU"] <- "1079 ± 140"


### these fluxes were calculated above already
### assign values
outDF$simulated[outDF$Variable=="NEP"] <- round(mean(fluxDF$NEP),2)
outDF$simulated[outDF$Variable=="GPP"] <- round(mean(fluxDF$GPP),2)
outDF$simulated[outDF$Variable=="NPP"] <- round(mean(fluxDF$NPP),2)
outDF$simulated[outDF$Variable=="CUE"] <- round(mean(fluxDF$NPP/fluxDF$GPP),2)
outDF$simulated[outDF$Variable=="RAU"] <- round(mean(fluxDF$RAU),2)

knitr::kable(outDF, caption = "Validation of major carbon fluxes")

```



#### Major nutrient pools and fluxes

\
Below we provide several variables to help constrain the nutrient cycles in the model, namely labile inorganic P pool (PLAB), soil net N and P mineralization rate (NMIN and PMIN), plant N and P uptake (NUP and PUP), and soil N and P leaching (NLEACH and PLEACH). We did not include total soil P pool, because its size could be misleading given that the majority of the P in the soil is stored as occluded form unavailable for plants. Note that in the table below, simulated results are for top 30 cm of the soil, but observed data are for top 10 cm only. 
    

```{r, echo=FALSE, message=FALSE, warning=FALSE}

### create a DF to store observation data for vegetation carbon stocks
pDF <- data.frame(c("PLAB", "PMIN", "NMIN", "NUP", "PUP",
                    "NLEACH", "PLEACH"), NA, NA)
colnames(pDF) <- c("Variable", 
                     "observed",
                     "simulated")

pDF$observed[pDF$Variable=="PLAB"] <- "0.17 ± 0.05"
pDF$observed[pDF$Variable=="PMIN"] <- "0.3 ± 0.08"
pDF$observed[pDF$Variable=="NMIN"] <- "8.81 ± 1.65"


### calcualte annual means in the simulated data
subDF <- subset(modDF, YEAR <= 2016 & YEAR > 2012)

poolDF <- summaryBy(PLAB~YEAR, data=subDF, FUN=mean, na.rm=T, keep.names=T)
fluxDF <- summaryBy(PMIN+NMIN+NLEACH+PLEACH+NUP+PUP~YEAR, data=subDF, FUN=sum, na.rm=T, keep.names=T)

### assign values
pDF$simulated[pDF$Variable=="PLAB"] <- round(poolDF$PLAB[poolDF$YEAR=="2016"], 3)
pDF$simulated[pDF$Variable=="PMIN"] <- round(mean(fluxDF$PMIN), 3)
pDF$simulated[pDF$Variable=="NMIN"] <- round(mean(fluxDF$NMIN), 3)
pDF$simulated[pDF$Variable=="PLEACH"] <- round(mean(fluxDF$PLEACH), 3)
pDF$simulated[pDF$Variable=="NLEACH"] <- round(mean(fluxDF$NLEACH), 3)
pDF$simulated[pDF$Variable=="PUP"] <- round(mean(fluxDF$PUP), 3)
pDF$simulated[pDF$Variable=="NUP"] <- round(mean(fluxDF$NUP), 3)

knitr::kable(pDF, caption = "Validation of key nutrient cycle variables")

```



#### Stoichiometry

\
Below we check major C:N, C:P, and N:P ratios. 


```{r, echo=FALSE, message=FALSE, warning=FALSE}

### create a DF to store observation data 
stDF <- data.frame(c("leaf", "sapwood", "wood", "fineroot", "soil"),
                   NA, NA, NA, NA, NA, NA)
colnames(stDF) <- c("Variable", "obsCN", "simCN", 
                    "obsCP", "simCP", "obsNP", "simNP")

stDF$obsCN[stDF$Variable=="leaf"] <- "35.5 ± 2.7"
stDF$obsCN[stDF$Variable=="sapwood"] <- "101.6 ± 14.7"
stDF$obsCN[stDF$Variable=="wood"] <- "110.2 ± 30.3"
stDF$obsCN[stDF$Variable=="fineroot"] <- "56.9 ± 4.6"
stDF$obsCN[stDF$Variable=="soil"] <- "13.8 ± 1.0"

stDF$obsCP[stDF$Variable=="leaf"] <- "722 ± 33"
stDF$obsCP[stDF$Variable=="sapwood"] <- "3705 ± 702"
stDF$obsCP[stDF$Variable=="wood"] <- "7696 ± 982"
stDF$obsCP[stDF$Variable=="fineroot"] <- "1626 ± 81"
stDF$obsCP[stDF$Variable=="soil"] <- "224 ± 39"

stDF$obsNP[stDF$Variable=="leaf"] <- "22.9 ± 0.1"
stDF$obsNP[stDF$Variable=="sapwood"] <- "35.6 ± 2.1"
stDF$obsNP[stDF$Variable=="wood"] <- "33.7 ± 2.7"
stDF$obsNP[stDF$Variable=="fineroot"] <- "28.7 ± 3.3"
stDF$obsNP[stDF$Variable=="soil"] <- "16.4 ± 3.4"


### create a DF to store simulated stocks
tmpDF <- data.frame(c("CL", "CW", "CFR", "CSOIL",
                     "NL", "NW", "NFR", "NSOIL",
                     "PL", "PW", "PFR", "PSOIL"), NA, NA)
colnames(tmpDF) <- c("Variable", 
                     "observed",
                     "simulated")

### calcualte annual means in the simulated data
poolDF <- subset(modDF, YEAR <= 2016 & YEAR > 2012)

poolDF <- summaryBy(CL+CW+CFR+CSOIL+NL+NW+NFR+NSOIL+PL+PW+PFR+PSOIL~YEAR, data=poolDF, FUN=mean, na.rm=T, keep.names=T)

### assign values
stDF$simCN[stDF$Variable=="leaf"] <- round(poolDF$CL[poolDF$YEAR=="2016"]/poolDF$NL[poolDF$YEAR=="2016"], 1)
stDF$simCN[stDF$Variable=="wood"] <- round(poolDF$CW[poolDF$YEAR=="2016"]/poolDF$NW[poolDF$YEAR=="2016"], 1)
stDF$simCN[stDF$Variable=="fineroot"] <- round(poolDF$CFR[poolDF$YEAR=="2016"]/poolDF$NFR[poolDF$YEAR=="2016"], 1)
stDF$simCN[stDF$Variable=="soil"] <- round(poolDF$CSOIL[poolDF$YEAR=="2016"]/poolDF$NSOIL[poolDF$YEAR=="2016"], 1)


stDF$simCP[stDF$Variable=="leaf"] <- round(poolDF$CL[poolDF$YEAR=="2016"]/poolDF$PL[poolDF$YEAR=="2016"], 1)
stDF$simCP[stDF$Variable=="wood"] <- round(poolDF$CW[poolDF$YEAR=="2016"]/poolDF$PW[poolDF$YEAR=="2016"], 1)
stDF$simCP[stDF$Variable=="fineroot"] <- round(poolDF$CFR[poolDF$YEAR=="2016"]/poolDF$PFR[poolDF$YEAR=="2016"], 1)
stDF$simCP[stDF$Variable=="soil"] <- round(poolDF$CSOIL[poolDF$YEAR=="2016"]/poolDF$PSOIL[poolDF$YEAR=="2016"], 1)


stDF$simNP[stDF$Variable=="leaf"] <- round(poolDF$NL[poolDF$YEAR=="2016"]/poolDF$PL[poolDF$YEAR=="2016"], 1)
stDF$simNP[stDF$Variable=="wood"] <- round(poolDF$NW[poolDF$YEAR=="2016"]/poolDF$PW[poolDF$YEAR=="2016"], 1)
stDF$simNP[stDF$Variable=="fineroot"] <- round(poolDF$NFR[poolDF$YEAR=="2016"]/poolDF$PFR[poolDF$YEAR=="2016"], 1)
stDF$simNP[stDF$Variable=="soil"] <- round(poolDF$NSOIL[poolDF$YEAR=="2016"]/poolDF$PSOIL[poolDF$YEAR=="2016"], 1)

knitr::kable(stDF, caption = "Validation of key stoichiometry")

```


#### Nutrient retranslocation coefficients

\
We only asked for the leaf N and P retranslocation flux in the output protocol. To obtain the coefficient, we will need the production flux. 

```{r, echo=FALSE, message=FALSE, warning=FALSE}

### subset and calculate
subDF <- subset(modDF, YEAR <= 2016 & YEAR > 2012)

tmpDF <- summaryBy(NGL+PGL+NLRETR+PLRETR~YEAR, data=subDF, FUN=sum, keep.names=T, na.rm=T)


### create DF for output
rtDF <- data.frame(c("leafN", "leafP"), NA, NA)
colnames(rtDF) <- c("Variable", "observed", "simulated")

### assign values
rtDF$observed[rtDF$Variable=="leafN"] <- "0.31 ± 0.04"
rtDF$observed[rtDF$Variable=="leafP"] <- "0.53 ± 0.04"

rtDF$simulated[rtDF$Variable=="leafN"] <- round(mean(tmpDF$NLRETR/tmpDF$NGL),2)
rtDF$simulated[rtDF$Variable=="leafP"] <- round(mean(tmpDF$PLRETR/tmpDF$PGL),2)


knitr::kable(rtDF, caption = "Validation of leaf retranslocation coefficients")




```




## Checking time-varying variables against validation data

#### Leaf area index

\
A time series LAI data over the period of 2012 - 2016 was provided for validation purpose. Models should aim to match the magnitude of LAI as well as its temporal patterns. Note that in the observed dataset, the LAI data is really indicative of the vegetation structure as well as canopy leaf area. 

\
The temporal pattern based on all available data is provided in the figure below:

```{r, fig.cap = "Time-varying LAI plot", fig.align="center", echo=FALSE, message=FALSE, warning=FALSE}

### validation LAI
laiDF <- read.csv("validation_dataset/EucFACE_LAI_2012_2016.csv")
laiDF <- laiDF[laiDF$Trt=="aCO2",]
laiDF$Date <- as.Date(as.character(laiDF$Date))

### simulated LAI, subset
subDF <- subset(modDF, YEAR <= 2016)
subDF <- subDF[,c("YEAR", "DOY", "Date", "LAI")]
subDF$Date <- as.Date(as.character(subDF$Date))

### merge the two dataset
testDF1 <- merge(subDF, laiDF, by="Date", all=T)

### plot all data
p1 <- ggplot(testDF1, aes(x=Date)) +
        geom_errorbar(aes(ymin=lai-laiSD,
                        ymax=lai+laiSD, color="obs"))+
        geom_line(aes(y=LAI, color="sim"), lwd = 1) +
        theme_linedraw() +
        theme(panel.grid.minor=element_blank(),
              axis.title.x = element_text(size=14), 
              axis.text.x = element_text(size=12),
              axis.text.y=element_text(size=12),
              axis.title.y=element_text(size=14),
              legend.text=element_text(size=12),
              legend.title=element_text(size=12),
              panel.grid.major=element_blank(),
              plot.title = element_text(size = 10, face = "bold"),
              legend.position="right")+
        ylab("LAI")+
        scale_colour_manual("", 
                            values = c("obs"="black", "sim"="red2"),
                            labels = c("Observed", "Simulated"))

    plot(p1)
    

```

\
Now we can check the goodness-of-fit of all days where observation is available. A perfect fit should have slope of 1 and intercept of 0. 

```{r, fig.cap = "Goodness of fit for LAI plot", fig.align="center", echo=FALSE, message=FALSE, warning=FALSE}

### subset only days where observations are available
testDF2 <- testDF1[complete.cases(testDF1$lai),]

lm.fit <- lm(testDF2$LAI~testDF2$lai)


### plot all data
p1 <- ggplot(testDF2, aes(x=lai, y=LAI)) +
        geom_point()+
        theme_linedraw() +
        geom_smooth(method="lm")+
        theme(panel.grid.minor=element_blank(),
              axis.title.x = element_text(size=14), 
              axis.text.x = element_text(size=12),
              axis.text.y=element_text(size=12),
              axis.title.y=element_text(size=14),
              legend.text=element_text(size=12),
              legend.title=element_text(size=12),
              panel.grid.major=element_blank(),
              plot.title = element_text(size = 10, face = "bold"),
              legend.position="right")+
        ylab("simulated LAI")+
        xlab("observed LAI")

    plot(p1)
    

```

\
The linear fit results are: 

```{r, echo=FALSE, message=FALSE, warning=FALSE}
print(paste0("slope = ", round(coef(lm.fit)[2], 2)))
print(paste0("intercept = ", round(coef(lm.fit)[1], 2)))

```



#### Soil respiration

\
The measured soil respiration rate represents both root and soil heterotrophic respiration flux. It was up-scaled from the LICOR chambers by averaging all measurements within the same treatment. It was a model product, in that we used DAMM model to establish relationship with soil temperature, and then obtained the daily rate throughout the year. Nevertheless, we expect modelers to provide a good match simulation to this dataset. 

\
Note that we didn't ask the modelers to output soil respiration flux in the output protocol. Please add heterotrophic respiration and root respiration to obtain soil respiration flux. Also, please note that, the unit for all carbon fluxes is given in the output protocol, as gC m-2 d-1. 


```{r, fig.cap = "Time-varying soil respiration plot", fig.align="center", echo=FALSE, message=FALSE, warning=FALSE}

### validation Rsoil
rsoilDF <- read.csv("validation_dataset/EucFACE_daily_soil_respiration_flux_2013_2015.csv")
rsoilDF <- rsoilDF[rsoilDF$Trt=="aCO2",]
rsoilDF$Date <- as.Date(as.character(rsoilDF$Date))

### convert unit, from mg m-2 d-1 to g m-2 d-1
rsoilDF$Rsoil_g_m2_d <- rsoilDF$Rsoil_mg_m2_d / 1000.0
rsoilDF$RsoilSD_g <- rsoilDF$RsoilSD / 1000.0


### simulated Rsoil, subset
subDF <- subset(modDF, YEAR <= 2015 & YEAR > 2012)
subDF <- subDF[,c("YEAR", "DOY", "Date", "RHET", "RCR", "RFR")]
subDF$Date <- as.Date(as.character(subDF$Date))
subDF$Rsoil_sim <- with(subDF, RHET+RCR+RFR)



### merge the two dataset
testDF1 <- merge(subDF, rsoilDF, by="Date", all=T)

### plot all data
p1 <- ggplot(testDF1, aes(x=Date)) +
        geom_errorbar(aes(ymin=Rsoil_g_m2_d-RsoilSD_g,
                        ymax=Rsoil_g_m2_d+RsoilSD_g, color="obs"))+
        geom_line(aes(y=Rsoil_sim, color="sim"), lwd = 1) +
        theme_linedraw() +
        theme(panel.grid.minor=element_blank(),
              axis.title.x = element_text(size=14), 
              axis.text.x = element_text(size=12),
              axis.text.y=element_text(size=12),
              axis.title.y=element_text(size=14),
              legend.text=element_text(size=12),
              legend.title=element_text(size=12),
              panel.grid.major=element_blank(),
              plot.title = element_text(size = 10, face = "bold"),
              legend.position="right")+
        ylab("Soil respiration flux")+
        scale_colour_manual("", 
                            values = c("obs"="black", "sim"="red2"),
                            labels = c("Observed", "Simulated"))

    plot(p1)
    


```


#### Soil water content

\
Soil water content is more complex and non-linear, depending on many model-specific settings. The validation dataset only serves as a guidance to evaluate your model performance. 


```{r, echo=FALSE, message=FALSE, warning=FALSE}

### validation Rsoil
swcDF <- read.csv("validation_dataset/EucFACE_SWC_2012_2019.csv")

### convert unit from VWC to kg H2O m-2
swcDF$WC_kg_m3 <- swcDF$VWC * swcDF$Bulk.den

swcDF$multiplier <- ifelse(swcDF$Depth%in%c(25,50,75,100,125,150), 0.25, 0.5)

swcDF$WC_kg_m2 <- swcDF$WC_kg_m3 * swcDF$multiplier

sumDF <- summaryBy(WC_kg_m2~Location+Date, FUN=sum, data=swcDF, keep.names=T, na.rm=T)

### process simulation data
subDF <- modDF[,c("YEAR", "DOY", "Date", "SW", "SWPA")]

plotDF <- merge(subDF, sumDF, by="Date", all=T)


### plot all data
p1 <- ggplot(plotDF, aes(x=Date)) +
        geom_point(aes(y=WC_kg_m2, color="obs"))+
        geom_point(aes(y=SWPA, color="sim"), lwd = 1) +
        theme_linedraw() +
        theme(panel.grid.minor=element_blank(),
              axis.title.x = element_text(size=14), 
              axis.text.x = element_text(size=12),
              axis.text.y=element_text(size=12),
              axis.title.y=element_text(size=14),
              legend.text=element_text(size=12),
              legend.title=element_text(size=12),
              panel.grid.major=element_blank(),
              plot.title = element_text(size = 10, face = "bold"),
              legend.position="right")+
        ylab("Soil water (kg m-2)")+
        scale_colour_manual("", 
                            values = c("obs"="black", "sim"="red2"),
                            labels = c("Observed", "Simulated"))

    plot(p1)


```

End. 